"""
Module: optimization/fitness.py
Complex fitness function for reactor core FA layout optimization.
"""
import numpy as np
from core_sim.core_grid import CoreGrid
from core_sim.fuel_assembly import FuelAssembly

# ==== Configurable parameters ====
T_BASE = 300.0       # °C, base temperature of new FA
BETA_T = 20.0        # °C, temperature rise at full wear
KAPPA_T = 0.1        # Neighbor influence coefficient
MAX_TEMP = 620.0     # °C, max safe temperature
GAMMA_T = 1.0        # Coefficient for overheating penalty
LAMBDA_T = 0.05      # Exponential growth rate for temp penalty
HOTSPOT_DIFF = 0.15  # life difference threshold for hotspot
E_MAX = 1.0          # Maximum energy per FA (scale)
EPSILON_E = 0.05     # Enrichment impact factor

# Dynamic weight boosting factor
C_BOOST = 0.1

# Initial weights (modifiable)
w_temp = 1.0
w_hotspot = 1.0
w_symmetry = 1.0
w_lifetime = 1.0
w_energy = 1.0

# ===== Helpers =====
def get_neighbors(grid: CoreGrid, x: int, y: int):
    """Return list of (neighbor_fa, weight) for Moore neighborhood."""
    offsets = [(-1,0,1.0),(1,0,1.0),(0,-1,1.0),(0,1,1.0),
               (-1,-1,0.5),(-1,1,0.5),(1,-1,0.5),(1,1,0.5)]
    size = grid.size
    result = []
    for dx, dy, w in offsets:
        nx, ny = x+dx, y+dy
        if 0 <= nx < size and 0 <= ny < size:
            result.append((grid.grid[nx, ny], w))
    return result


def calculate_temperature(fa: FuelAssembly, grid: CoreGrid) -> float:
    """
    Compute FA temperature with neighbor correction.
    T_i = T_BASE + BETA_T*(1-life_i) + KAPPA_T * avg(T_j - T_i)
    """
    Ti = T_BASE + BETA_T * (1.0 - fa.life)
    deltas = []
    x,y = fa.position
    for neighbor, _ in get_neighbors(grid, x, y):
        if neighbor:
            Tj = T_BASE + BETA_T * (1.0 - neighbor.life)
            deltas.append(Tj - Ti)
    if deltas:
        Ti += KAPPA_T * np.mean(deltas)
    return Ti


def f_hotspots(grid: CoreGrid) -> float:
    """Sum of hotspots: max(0, |life_i-life_j|-HOTSPOT_DIFF)."""
    total = 0.0
    for fa in grid.get_all_fuel_assemblies():
        if fa.fa_type != "movable":
            continue
        x,y = fa.position
        for neighbor, _ in get_neighbors(grid, x, y):
            if neighbor and neighbor.fa_type == "movable":
                diff = abs(fa.life - neighbor.life) - HOTSPOT_DIFF
                if diff > 0:
                    total += diff
    return total


def f_overheat_penalty(grid: CoreGrid) -> float:
    """Exponential penalty for FA above MAX_TEMP."""
    penalty = 0.0
    for fa in grid.get_all_fuel_assemblies():
        if fa.fa_type != "movable":
            continue
        Ti = calculate_temperature(fa, grid)
        if Ti > MAX_TEMP:
            penalty += GAMMA_T * np.exp(LAMBDA_T * (Ti - MAX_TEMP))
    return penalty


def f_energy(grid: CoreGrid) -> float:
    """Total energy generated by movable FA."""
    total = 0.0
    for fa in grid.get_all_fuel_assemblies():
        if fa.fa_type == "movable":
            total += E_MAX * fa.life * (1.0 + EPSILON_E * fa.enrichment)
    return total


def f_lifetime(grid: CoreGrid) -> float:
    """Average remaining life of movable FA."""
    lives = [fa.life for fa in grid.get_all_fuel_assemblies() if fa.fa_type == "movable"]
    return np.mean(lives) if lives else 0.0


def f_symmetry(grid: CoreGrid) -> float:
    """Symmetry score: 1 - (sum|life diff| + |E diff|)/(2*N)."""
    size = grid.size
    diffs = 0.0
    count = 0
    movable = [fa for fa in grid.get_all_fuel_assemblies() if fa.fa_type == "movable"]
    N = len(movable)
    for fa in movable:
        x,y = fa.position
        mirror = grid.grid[size-1-x, size-1-y]
        if mirror.fa_type == "movable":
            diffs += abs(fa.life - mirror.life)
            Ei = E_MAX * fa.life * (1.0 + EPSILON_E * fa.enrichment)
            Ej = E_MAX * mirror.life * (1.0 + EPSILON_E * mirror.enrichment)
            diffs += abs(Ei - Ej)
            count += 1
    if N > 0:
        score = 1.0 - diffs/(2.0 * N)
        return max(0.0, score)
    return 0.0


def adjust_weights(grid: CoreGrid):
    """Boost weights if safety limits are exceeded."""
    global w_temp, w_hotspot
    over_temp = sum(1 for fa in grid.get_all_fuel_assemblies()
                     if fa.fa_type=="movable" and calculate_temperature(fa,grid)>MAX_TEMP)
    hotspots = f_hotspots(grid)
    if over_temp > 5 or hotspots > 10:
        w_temp *= (1.0 + C_BOOST)
        w_hotspot *= (1.0 + C_BOOST)


def fitness(grid: CoreGrid, report: bool=False) -> float:
    """
    Compute overall fitness. Lower is better.
    Components include overheat penalty, hotspots, energy (subtracted),
    symmetry penalty, lifetime reward, with dynamic weights.
    """
    adjust_weights(grid)
    overheat = f_overheat_penalty(grid)
    hot = f_hotspots(grid)
    energy = f_energy(grid)
    life = f_lifetime(grid)
    sym = f_symmetry(grid)

    score = w_temp * overheat + w_hotspot * hot - w_energy * energy \
            + w_symmetry * (1.0 - sym) - w_lifetime * life

    if report:
        print(f"Overheat: {overheat:.3f}, Hotspots: {hot:.3f}, "
              f"Energy: {-energy:.3f}, Lifetime: {life:.3f}, Symmetry Penalty: {1-sym:.3f}")
        print(f"Weights: temp={w_temp:.2f}, hotspot={w_hotspot:.2f}, "
              f"sym={w_symmetry:.2f}, life={w_lifetime:.2f}, energy={w_energy:.2f}")
        print(f"Total fitness: {score:.3f}")
    return score